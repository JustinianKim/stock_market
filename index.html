<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Investment Game - No Overlap</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #0a0a0a;
            color: white;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        /* 시작 화면 스타일 */
        #start-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        #start-btn {
            padding: 20px 50px;
            font-size: 24px;
            font-weight: bold;
            background: #00ff88;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: 0.2s;
        }
        #start-btn:hover { transform: scale(1.1); background: #00cc6e; }

        #ui-layer {
            position: absolute;
            top: 20px; left: 20px; right: 20px;
            display: flex; justify-content: space-between;
            z-index: 100; pointer-events: none;
        }
        .ui-box {
            background: rgba(20, 20, 20, 0.98);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid #444;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        #balance-display { font-size: 26px; font-weight: 800; color: #00ff88; }
        #timer-display { font-size: 18px; color: #ffcc00; font-family: 'Monaco', monospace; }
        #end-btn {
            margin-top: 10px; padding: 10px;
            background: #e74c3c; color: white;
            border: none; border-radius: 6px;
            cursor: pointer; font-weight: bold; width: 100%;
        }
        #game-container { position: relative; width: 100%; height: 100%; z-index: 10; }
        .stock {
            position: absolute; border-radius: 50%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; transition: border 0.1s, background 0.1s; /* 위치 이동은 JS로 처리하므로 transition 제거 */
            font-weight: 900; background: rgba(35, 35, 35, 0.9);
            user-select: none; transform: translate(-50%, -50%);
            /* 부드러운 이동을 위해 will-change 추가 */
            will-change: top, left, width, height; 
        }
        .stock.owned { border: 7px solid #ffffff; box-shadow: 0 0 35px rgba(255,255,255,0.5); z-index: 50; }
        .up { color: #ff4757; }
        .down { color: #3498db; }
        .arrow-label { font-size: 11px; line-height: 1; margin-bottom: 3px; font-weight: 800; }
        .price-label { font-size: 18px; letter-spacing: -0.5px; }

        #result-screen {
            display: none; position: fixed;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #111; padding: 30px 40px;
            border-radius: 20px; border: 2px solid #444;
            text-align: center; z-index: 1000;
            box-shadow: 0 0 100px rgba(0,0,0,0.9); width: 500px;
        }
        #asset-chart { background: #1a1a1a; margin-top: 20px; border-radius: 10px; border: 1px solid #333; }
    </style>
</head>
<body>

<div id="start-screen">
    <h1 style="color: #ffcc00; margin-bottom: 30px;">INVESTMENT GAME</h1>
    <input type="number" id="time-input" placeholder="플레이 시간(분) 입력" style="padding: 10px; border-radius: 5px; border: none; margin-bottom: 20px; text-align: center; width: 200px;">
    <button id="start-btn" onclick="initGame()">START GAME</button>
    <p style="color: #666; margin-top: 15px;">* 미입력 시 무제한 모드로 시작됩니다.</p>
</div>

<div id="ui-layer">
    <div class="ui-box">
        <div id="timer-display">TIME: 0.0s / ∞</div>
    </div>
    <div class="ui-box">
        <div id="balance-display">$ <span id="balance">1,000</span></div>
        <button id="end-btn" onclick="endGame()">FINISH TRADE</button>
    </div>
</div>

<div id="game-container"></div>

<div id="result-screen">
    <h2 style="color: #ffcc00; margin-bottom: 20px;">TRADE REPORT</h2>
    <div style="margin: 10px 0;">최대 보유액: <span id="max-stat" style="color:#00ff88; font-weight: bold;"></span></div>
    <div style="margin: 10px 0;">최소 보유액: <span id="min-stat" style="color:#ff4757; font-weight: bold;"></span></div>
    <div style="margin: 10px 0;">초당 평균 손익: <span id="avg-stat" style="font-weight: bold;"></span></div>
    <canvas id="asset-chart" width="420" height="180"></canvas>
    <hr style="border:0; border-top:1px solid #333; margin:20px 0;">
    <button onclick="location.reload()" style="padding: 10px 25px; cursor: pointer; border-radius: 8px; font-weight: bold; background:#fff; border:none;">RESTART</button>
</div>

<script>
    let balance = 1000;
    let startTime;
    let isGameRunning = false;
    let maxBalance = 1000;
    let minBalance = 1000;
    let stocks = [];
    let timeLimit = 0;
    let assetHistory = [1000];

    const container = document.getElementById('game-container');
    const balanceEl = document.getElementById('balance');
    const timerEl = document.getElementById('timer-display');

    // 게임 초기화 및 시작
    function initGame() {
        const inputVal = document.getElementById('time-input').value;
        if (inputVal && !isNaN(inputVal)) {
            timeLimit = parseFloat(inputVal) * 60;
        }
        
        document.getElementById('start-screen').style.display = 'none';
        isGameRunning = true;
        startTime = Date.now();
        
        // 자산 기록 시작
        setInterval(() => {
            if (!isGameRunning) return;
            let totalAsset = balance;
            stocks.forEach(s => { if (s.owned) totalAsset += s.price; });
            assetHistory.push(totalAsset);
        }, 1000);

        gameLoop();
    }

    function getPyramidPeak() {
        const rand = Math.random() * 100;
        if (rand < 2) return Math.random() * 2000 + 8000;
        if (rand < 7) return Math.random() * 4000 + 4000;
        if (rand < 15) return Math.random() * 2500 + 1500;
        return Math.random() * 800;
    }

    function determineStage(price) {
        const baseProb = (price / 2500); 
        const rand = Math.random() + baseProb;
        if (rand > 2.6) return { stage: 3, arrows: '▲▲▲', mult: 12 };
        if (rand > 1.4) return { stage: 2, arrows: '▲▲', mult: 5 };
        return { stage: 1, arrows: '▲', mult: 1 };
    }

    function createStock() {
        if (stocks.length >= 15 || !isGameRunning) return;

        // [변경점 1] 겹치지 않는 위치 찾기 시도 (최대 50번 시도)
        let x, y, isValidPosition = false;
        let attempts = 0;
        const initialRadius = 30; // 초기 생성 반지름 예측값

        while (!isValidPosition && attempts < 50) {
            x = 100 + Math.random() * (window.innerWidth - 200);
            y = 100 + Math.random() * (window.innerHeight - 200);
            isValidPosition = true;

            for (let s of stocks) {
                const dx = x - s.x;
                const dy = y - s.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < initialRadius + s.radius + 10) { // 10px 여유
                    isValidPosition = false;
                    break;
                }
            }
            attempts++;
        }

        // 공간이 없으면 생성 포기
        if (!isValidPosition && stocks.length > 5) return; 

        const stockDiv = document.createElement('div');
        stockDiv.className = 'stock';
        const initialStatus = determineStage(1);
        
        const stockData = {
            el: stockDiv, x: x, y: y, radius: initialRadius, price: 1,
            owned: false, state: 'UP', peak: getPyramidPeak(),
            baseSpeed: Math.random() * 0.5 + 0.3,
            currentStage: initialStatus,
            lastStageUpdate: Date.now()
        };

        stockDiv.onmousedown = () => {
            if (!isGameRunning) return;
            if (!stockData.owned) {
                if (balance >= stockData.price) {
                    balance -= Math.floor(stockData.price);
                    stockData.owned = true;
                    stockData.el.classList.add('owned');
                }
            } else {
                balance += Math.floor(stockData.price);
                stockData.owned = false;
                stockData.el.classList.remove('owned');
            }
        };
        container.appendChild(stockDiv);
        stocks.push(stockData);
    }

    function drawGraph() {
        const canvas = document.getElementById('asset-chart');
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height, p = 20;
        const maxVal = Math.max(...assetHistory, 2000), minVal = Math.min(...assetHistory, 0);
        const range = maxVal - minVal;
        ctx.clearRect(0,0,w,h);
        ctx.strokeStyle = '#333'; ctx.setLineDash([5,5]); ctx.beginPath();
        const startY = h - p - ((1000 - minVal) / range) * (h - 2*p);
        ctx.moveTo(p, startY); ctx.lineTo(w-p, startY); ctx.stroke(); ctx.setLineDash([]);
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2; ctx.beginPath();
        assetHistory.forEach((val, i) => {
            const x = p + (i / (assetHistory.length - 1)) * (w - 2 * p);
            const y = h - p - ((val - minVal) / range) * (h - 2 * p);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.stroke();
    }

    function endGame() {
        if (!isGameRunning) return;
        isGameRunning = false;
        stocks.forEach(s => { if (s.owned) balance += Math.floor(s.price); });
        assetHistory.push(balance);
        const totalTime = (Date.now() - startTime) / 1000;
        document.getElementById('max-stat').innerText = `$ ${Math.floor(maxBalance).toLocaleString()}`;
        document.getElementById('min-stat').innerText = `$ ${Math.floor(minBalance).toLocaleString()}`;
        document.getElementById('avg-stat').innerText = `$ ${((balance - 1000) / (totalTime || 1)).toFixed(2)} / sec`;
        document.getElementById('result-screen').style.display = 'block';
        drawGraph();
    }

    // [변경점 2] 물리 엔진: 원들이 겹치면 서로 밀어내고 화면 안으로 제한하는 함수
    function resolveCollisions() {
        // 1. 서로 밀어내기
        for (let i = 0; i < stocks.length; i++) {
            for (let j = i + 1; j < stocks.length; j++) {
                const s1 = stocks[i];
                const s2 = stocks[j];
                const dx = s2.x - s1.x;
                const dy = s2.y - s1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = s1.radius + s2.radius + 10; // 여유 공간 10px

                if (dist < minDist) {
                    const angle = Math.atan2(dy, dx);
                    const overlap = minDist - dist;
                    const force = 0.1; // 부드럽게 밀어내는 힘

                    // 겹친 만큼 반대 방향으로 이동
                    const moveX = Math.cos(angle) * overlap * force;
                    const moveY = Math.sin(angle) * overlap * force;

                    s1.x -= moveX;
                    s1.y -= moveY;
                    s2.x += moveX;
                    s2.y += moveY;
                }
            }
        }

        // 2. 화면 밖으로 나가지 않게 하기
        const width = window.innerWidth;
        const height = window.innerHeight;
        const padding = 100; // UI 고려한 여백

        stocks.forEach(s => {
            if (s.x < s.radius + 20) s.x = s.radius + 20;
            if (s.x > width - s.radius - 20) s.x = width - s.radius - 20;
            if (s.y < s.radius + 80) s.y = s.radius + 80; // 상단 UI 공간
            if (s.y > height - s.radius - 20) s.y = height - s.radius - 20;
        });
    }

    function gameLoop() {
        if (!isGameRunning) return;
        const now = Date.now();
        const elapsed = (now - startTime) / 1000;
        const limitStr = timeLimit > 0 ? `${timeLimit}s` : "∞";
        timerEl.innerText = `TIME: ${elapsed.toFixed(1)}s / ${limitStr}`;
        if (timeLimit > 0 && elapsed >= timeLimit) { endGame(); return; }
        
        if (stocks.length < 15 && Math.random() < 0.05) createStock();

        let currentTickAsset = balance;

        // 1. 가격 변동 및 반지름 계산 업데이트
        for (let i = stocks.length - 1; i >= 0; i--) {
            const s = stocks[i];
            if (now - s.lastStageUpdate > 1200) { s.currentStage = determineStage(s.price); s.lastStageUpdate = now; }
            
            const st = s.currentStage;
            const arrows = s.state === 'UP' ? st.arrows : st.arrows.replace(/▲/g, '▼');
            const fall = s.state === 'DOWN' ? 2.2 : 1.0;
            const vol = s.baseSpeed * (1 + Math.pow(s.price / 2000, 2)) * st.mult * fall;
            
            if (s.state === 'UP') { s.price += vol; if (s.price >= s.peak) s.state = 'DOWN'; }
            else { s.price -= vol; if (s.price <= 0) { container.removeChild(s.el); stocks.splice(i, 1); continue; } }
            
            if (s.owned) currentTickAsset += s.price;
            
            // 반지름 계산 (DOM 업데이트 전에 미리 계산)
            s.radius = (60 + (s.price / 10000) * 150) / 2; 

            // DOM 텍스트 업데이트
            s.el.className = `stock ${s.state === 'UP' ? 'up' : 'down'} ${s.owned ? 'owned' : ''}`;
            s.el.innerHTML = `<div class="arrow-label">${arrows}</div><div class="price-label">${Math.floor(s.price).toLocaleString()}</div>`;
        }

        // 2. [변경점] 충돌 해결 (위치 조정)
        resolveCollisions();

        // 3. 최종 위치를 DOM에 반영
        stocks.forEach(s => {
            s.el.style.width = `${s.radius * 2}px`;
            s.el.style.height = `${s.radius * 2}px`;
            s.el.style.left = `${s.x}px`;
            s.el.style.top = `${s.y}px`;
        });

        if (currentTickAsset > maxBalance) maxBalance = currentTickAsset;
        if (currentTickAsset < minBalance) minBalance = currentTickAsset;
        balanceEl.innerText = Math.floor(balance).toLocaleString();
        
        requestAnimationFrame(gameLoop);
    }
</script>
</body>
</html>
